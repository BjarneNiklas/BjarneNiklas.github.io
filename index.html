<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EA 7 - Z-Buffer Visualisierung</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a2e;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(45, 45, 45, 0.8);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            max-width: 280px;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #ffcc00;
        }

        #controls p {
            margin: 8px 0;
        }

        #controls .highlight {
            color: #e70e89;
            font-weight: bold;
        }

        #controls .author {
            margin-top: 15px;
            font-size: 12px;
            color: #bbb;
            text-align: right;
        }
    </style>
</head>
<body onload="initApp()">
    <div id="controls">
        <h3>EA 7 - Z-Buffer Visualisierung</h3>
        <p><span class="highlight">WASD:</span> Kamera bewegen (auf XY-Ebene)</p>
        <p><span class="highlight">Pfeiltasten:</span> Szene rotieren</p>
        <p class="author">Autor: Bjarne Niklas Luttermann (THL)</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const zBufferMaterial = new THREE.ShaderMaterial({
            uniforms: {
                cameraNear: { value: camera.near },
                cameraFar: { value: camera.far },
            },
            vertexShader: `
                varying float vDepth;
                void main() {
                    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * modelViewPosition;
                    vDepth = -modelViewPosition.z;
                }
            `,
            fragmentShader: `
                varying float vDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                
                void main() {
                    float depth = exp(-vDepth * 0.15);
                    gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
                }
            `
        });

        const houseBase = new THREE.BoxGeometry(2, 2, 2);
        const house = new THREE.Mesh(houseBase, zBufferMaterial);
        house.position.set(-2, 0, 0);
        scene.add(house);

        const roofGeometry = new THREE.ConeGeometry(1.5, 1.5, 4);
        const roof = new THREE.Mesh(roofGeometry, zBufferMaterial);
        roof.position.set(-2, 1.75, 0);
        scene.add(roof);

        const outerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32),
            zBufferMaterial
        );
        outerSphere.position.set(2, 0, -2);
        scene.add(outerSphere);

        const innerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 32, 32),
            zBufferMaterial
        );
        innerSphere.position.set(1, 0, -2);
        scene.add(innerSphere);

        const cylinder = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, 2, 32),
            zBufferMaterial
        );
        cylinder.position.set(0, 0, 2);
        scene.add(cylinder);

        const cylinder2 = new THREE.Mesh(
            new THREE.CylinderGeometry(0.25, 1, 2, 32),
            zBufferMaterial
        );
        cylinder2.position.set(3, -0.5, 1);
        scene.add(cylinder2);

        const torus = new THREE.Mesh(
            new THREE.TorusGeometry(1, 0.3, 16, 100),
            zBufferMaterial
        );
        torus.position.set(3, 1.5, 1);
        scene.add(torus);

        const pyramidGeometry = new THREE.ConeGeometry(1, 1, 4);
        const pyramid = new THREE.Mesh(pyramidGeometry, zBufferMaterial);
        pyramid.position.set(-4.5, -0.5, -1);
        scene.add(pyramid);

        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(3, 1, 1),
            zBufferMaterial
        );
        cube.position.set(-3, -1, -1);
        scene.add(cube);

        camera.position.z = 6;
        camera.position.y = 0;

        const keys = {};
        const moveSpeed = 0.1;
        const rotateSpeed = 0.02;

        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        function animate() {
            requestAnimationFrame(animate);

            // Camera Movement
            if (keys['w'] || keys['W']) camera.position.y += moveSpeed;
            if (keys['s'] || keys['S']) camera.position.y -= moveSpeed;
            if (keys['a'] || keys['A']) camera.position.x -= moveSpeed;
            if (keys['d'] || keys['D']) camera.position.x += moveSpeed;

            // Rotation
            if (keys['ArrowLeft']) scene.rotation.y += rotateSpeed;
            if (keys['ArrowRight']) scene.rotation.y -= rotateSpeed;
            if (keys['ArrowUp']) scene.rotation.x += rotateSpeed;
            if (keys['ArrowDown']) scene.rotation.x -= rotateSpeed;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
